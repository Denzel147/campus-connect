// WebSocket Client for CampusConnect// Simple WebSocket client for real-time notifications and updatesclass WebSocketManager {  constructor() {    this.socket = null;    this.isConnected = false;    this.reconnectAttempts = 0;    this.maxReconnectAttempts = 5;    this.reconnectDelay = 1000; // Start with 1 second  }  connect() {    try {      // Only connect if we have a user token      const token = localStorage.getItem('accessToken');      if (!token) {        console.log('No token found, skipping WebSocket connection');        return;      }      const wsUrl = `ws://localhost:8080?token=${token}`;      this.socket = new WebSocket(wsUrl);            this.socket.onopen = () => {        console.log('WebSocket connected successfully');        this.isConnected = true;        this.reconnectAttempts = 0;        this.reconnectDelay = 1000;                // Send initial presence        this.send({          type: 'presence',          status: 'online'        });      };      this.socket.onmessage = (event) => {        try {          const data = JSON.parse(event.data);          this.handleMessage(data);        } catch (error) {          console.error('Failed to parse WebSocket message:', error);        }      };      this.socket.onclose = (event) => {        console.log('WebSocket connection closed:', event.code, event.reason);        this.isConnected = false;                // Attempt to reconnect unless it was a deliberate close        if (event.code !== 1000 && this.reconnectAttempts < this.maxReconnectAttempts) {          this.scheduleReconnect();        }      };      this.socket.onerror = (error) => {        console.error('WebSocket error:', error);        this.isConnected = false;      };          } catch (error) {      console.error('Failed to establish WebSocket connection:', error);    }  }  scheduleReconnect() {    this.reconnectAttempts++;    const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1);        console.log(`Attempting to reconnect in ${delay}ms (attempt ${this.reconnectAttempts})`);        setTimeout(() => {      this.connect();    }, delay);  }  handleMessage(data) {    switch (data.type) {      case 'notification':        this.showNotification(data.notification);        break;      case 'transaction_update':        this.handleTransactionUpdate(data.transaction);        break;      case 'new_message':        this.handleNewMessage(data.message);        break;      case 'user_status':        this.handleUserStatusUpdate(data.user);        break;      default:        console.log('Unknown message type:', data.type);    }  }  showNotification(notification) {    // Create a custom event that the main app can listen to    const event = new CustomEvent('websocket-notification', {      detail: notification    });    window.dispatchEvent(event);  }  handleTransactionUpdate(transaction) {    const event = new CustomEvent('transaction-update', {      detail: transaction    });    window.dispatchEvent(event);  }  handleNewMessage(message) {    const event = new CustomEvent('new-message', {      detail: message    });    window.dispatchEvent(event);  }  handleUserStatusUpdate(user) {    const event = new CustomEvent('user-status-update', {      detail: user    });    window.dispatchEvent(event);  }  send(data) {    if (this.isConnected && this.socket) {      try {        this.socket.send(JSON.stringify(data));      } catch (error) {        console.error('Failed to send WebSocket message:', error);      }    } else {      console.warn('WebSocket not connected, cannot send message');    }  }  disconnect() {    if (this.socket) {      this.socket.close(1000, 'User disconnected');      this.socket = null;      this.isConnected = false;    }  }  // Public methods for sending specific message types  sendPresence(status) {    this.send({      type: 'presence',      status: status    });  }  joinRoom(roomId) {    this.send({      type: 'join_room',      roomId: roomId    });  }  leaveRoom(roomId) {    this.send({      type: 'leave_room',      roomId: roomId    });  }  sendTyping(roomId, isTyping) {    this.send({      type: 'typing',      roomId: roomId,      isTyping: isTyping    });  }}// Global WebSocket manager instancewindow.wsManager = new WebSocketManager();// Auto-connect when the page loads if user is authenticateddocument.addEventListener('DOMContentLoaded', () => {  const token = localStorage.getItem('accessToken');  if (token) {    // Delay connection to ensure the main app is loaded    setTimeout(() => {      window.wsManager.connect();    }, 1000);  }});// Disconnect when user logs outwindow.addEventListener('storage', (event) => {  if (event.key === 'accessToken' && !event.newValue) {    // Token was removed (user logged out)    window.wsManager.disconnect();  } else if (event.key === 'accessToken' && event.newValue) {    // Token was added (user logged in)    setTimeout(() => {      window.wsManager.connect();    }, 500);  }});// Disconnect when page is closedwindow.addEventListener('beforeunload', () => {  window.wsManager.disconnect();});